{"meta":{"title":"Gilgamesh","subtitle":null,"description":"Life Of Konjac","author":"James","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Codeforce 1040A Palindrome Dance （模拟）No.13","slug":"13_1040A","date":"2018-09-06T10:31:42.831Z","updated":"2018-09-06T10:31:20.144Z","comments":true,"path":"2018/09/06/13_1040A/","link":"","permalink":"http://yoursite.com/2018/09/06/13_1040A/","excerpt":"","text":"Palindrome Dance传送A group of n dancers rehearses a performance for the closing ceremony. The dancers are arranged in a row, they’ve studied their dancing moves and can’t change positions. For some of them, a white dancing suit is already bought, for some of them — a black one, and for the rest the suit will be bought in the future. On the day when the suits were to be bought, the director was told that the participants of the olympiad will be happy if the colors of the suits on the scene will form a palindrome. A palindrome is a sequence that is the same when read from left to right and when read from right to left. The director liked the idea, and she wants to buy suits so that the color of the leftmost dancer’s suit is the same as the color of the rightmost dancer’s suit, the 2nd left is the same as 2nd right, and so on. The director knows how many burls it costs to buy a white suit, and how many burls to buy a black suit. You need to find out whether it is possible to buy suits to form a palindrome, and if it’s possible, what’s the minimal cost of doing so. Remember that dancers can not change positions, and due to bureaucratic reasons it is not allowed to buy new suits for the dancers who already have suits, even if it reduces the overall spending. InputThe first line contains three integers n, a, and b (1≤n≤20, 1≤a,b≤100) — the number of dancers, the cost of a white suit, and the cost of a black suit. The next line contains n numbers ci, i-th of which denotes the color of the suit of the i-th dancer. Number 0 denotes the white color, 1 — the black color, and 2 denotes that a suit for this dancer is still to be bought. OutputIf it is not possible to form a palindrome without swapping dancers and buying new suits for those who have one, then output -1. Otherwise, output the minimal price to get the desired visual effect. Examplesinput 5 100 10 1 2 1 2 output 101 input 3 10 121 2 0 output -1 input 3 12 10 1 0 output 0 NoteIn the first sample, the cheapest way to obtain palindromic colors is to buy a black suit for the third from left dancer and a white suit for the rightmost dancer. In the second sample, the leftmost dancer’s suit already differs from the rightmost dancer’s suit so there is no way to obtain the desired coloring. In the third sample, all suits are already bought and their colors form a palindrome. 题目大意:合唱队教练想让大家的西装颜色形成回文，问你最少需要多少钱？ps:已经有西装的人不能换颜色 做法:两个指针模拟一遍（因为偷懒用了两个数组），对应的两人都没衣服穿就穿最便宜的，衣服颜色不同就输出-1 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,a[100010],b[100010];int cw,cb;long long ans;void debug()&#123; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;b[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;cw&gt;&gt;cb; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; b[n-i+1]=a[i]; &#125; for(int i=1;i&lt;=(n+1)/2;i++)&#123; if(a[i]==b[i]&amp;&amp;a[i]!=2) continue; else&#123; if(a[i]!=2&amp;&amp;b[i]!=2)&#123; cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0; &#125; if(a[i]==2&amp;&amp;b[i]==0)&#123; ans+=cw; &#125; if(a[i]==0&amp;&amp;b[i]==2)&#123; ans+=cw; &#125; if(a[i]==2&amp;&amp;b[i]==1)&#123; ans+=cb; &#125; if(a[i]==1&amp;&amp;b[i]==2)&#123; ans+=cb; &#125; if(a[i]==2&amp;&amp;b[i]==2)&#123; ans+=min(cw,cb); if(n%2==0) ans+=min(cw,cb); else if(i!=(n+1)/2)&#123; ans+=min(cw,cb); &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Codeforce 1037C Equalize (贪心?)【2018.9.2混合场】No.12","slug":"12_1037C","date":"2018-09-05T08:14:50.280Z","updated":"2018-09-05T08:17:49.584Z","comments":true,"path":"2018/09/05/12_1037C/","link":"","permalink":"http://yoursite.com/2018/09/05/12_1037C/","excerpt":"","text":"Equalize传送You are given two binary strings a and b of the same length. You can performthe following two operations on the string a:Swap any two bits at indices i and j respectively (1≤i,j≤n), the cost of this operation is |i−j|, that is, the absolute difference between i and j.Select any arbitrary index i (1≤i≤n) and flip (change 0 to 1 or 1 to 0) the bit at this index. The cost of this operation is 1.Find the minimum cost to make the string a equal to b. It is not allowed to modify string b. InputThe first line contains a single integer n (1≤n≤106) — the length of the strings a and b.The second and third lines contain strings a and b respectively.Both strings a and b have length n and contain only ‘0’ and ‘1’. OutputOutput the minimum cost to make the string a equal to b. Examplesinput 3100001 output 2 input 401010011 output 1 ####NoteIn the first example, one of the optimal solutions is to flip index 1 and index 3, the string a changes in the following way: “100” → “000” →”001”. The cost is 1+1=2.The other optimal solution is to swap bits and indices 1 and 3, the string a changes then “100” → “001”, the cost is also |1−3|=2. In the second example, the optimal solution is to swap bits at indices 2 and 3, the string a changes as “0101” → “0011”. The cost is |2−3|=1. 题目大意：给两个长度为n的0101010字符串二进制数你可以进行两个操作：1.把1变为0或把0变为1，消耗一点能量2.交换1和0，消耗|i-j|的能量问最少消耗多少能量，才能把第一个二进制数变成第二个二进制数 做法：noip期间我好像做过类似的题还有这个题比B好像还简单啊喂！贪心？？？反正如果用2操作的话不是相邻的交换就不如直接1操作所以遍历一遍所有需要改动的 1或0 看看周围有没有同样需要改动的 0或1如果有，2操作交换，其余的，用1操作 代码：12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[1000010],b[1000010],c[1000010];int n,num,ans;int read()&#123; int res=0;char ch=0; while(!isdigit(ch)) ch=getchar(); if(isdigit(ch)) res=ch-'0'; return res;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=n;i++)&#123; b[i]=read(); c[i]=(a[i]+b[i])%2; if(c[i]==1) num++; &#125; for(int i=1;i&lt;=n;i++)&#123; if(c[i]==1&amp;&amp;c[i+1]==1&amp;&amp;a[i]+a[i+1]==1)&#123; ans+=1; num-=2; i++; &#125; &#125; ans+=num; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[],"tags":[]},{"title":"Codeforce 1037B Reach Median【2018.9.2混合场】No.11","slug":"11_1037B","date":"2018-09-05T03:11:08.822Z","updated":"2018-09-05T03:13:01.635Z","comments":true,"path":"2018/09/05/11_1037B/","link":"","permalink":"http://yoursite.com/2018/09/05/11_1037B/","excerpt":"","text":"Reach Median传送You are given an array a of n integers and an integer s. It is guaranteed thatn is odd.In one operation you can either increase or decrease any single element by one. Calculate the minimum number of operations required to make the median of the array being equal to s.The median of the array with odd length is the value of the element which is located on the middle position after the array is sorted. For example, the median of the array 6,5,8 is equal to 6, since if we sort this array we will get 5,6,8, and 6 is located on the middle position. InputThe first line contains two integers n and s (1≤n≤2⋅105−1, 1≤s≤109) — the length of the array and the required value of median.The second line contains n integers a1,a2,…,an (1≤ai≤109) — the elements of the array a.It is guaranteed that n is odd. Examplesinput 3 86 5 8 output 2 input 7 2021 15 12 11 20 19 12 output 6 NoteIn the first sample, 6 can be increased twice. The array will transform to 8,5,8, which becomes 5,8,8 after sorting, hence the median is equal to 8.In the second sample, 19 can be increased once and 15 can be increased five times. The array will become equal to 21,20,12,11,20,20,12. If we sort this array we get 11,12,12,20,20,20,21, this way the median is 20. 题目大意:有n个数，每次可以对一个数进行+1或-1的操作，问最少需要几次才能使得该组数的中位数等于s 做法：和540B school mark 有点类似贪心：尽可能的改变离中位数近的数因为只有两种情况：全部加分操作或者全部减分操作所以分离大于等于s的和小于s的数，再分别排序判断情况：1.如果需要加，就从小于s的数组中，从大到小加2.如果需要减，就从大于s的数组中，从小到大减 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,s;int a[200010],b[200010],c[200010];int num1,num2,mid;long long ans;int read()&#123; int res=0;char ch; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) res=res*10+ch-'0',ch=getchar(); return res;&#125;bool cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; n=read();s=read(); mid=(n/2)+1; for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); if(a[i]&gt;=s)&#123; num1++; b[num1]=a[i]; &#125; else&#123; num2++; c[num2]=a[i]; &#125; &#125; sort(b+1,b+1+num1); sort(c+1,c+1+num2,cmp); if(num1&gt;=mid)&#123; int t=num1-mid+1; for(int i=1;i&lt;=t;i++)&#123; ans+=b[i]-s; &#125; &#125; else&#123; int t=num2-mid+1; for(int i=1;i&lt;=t;i++)&#123; ans+=s-c[i]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[],"tags":[]},{"title":"Codeforce 1037A Packets (数论?）【2018.9.2混合场】No.10","slug":"10_1037A","date":"2018-09-03T04:10:12.688Z","updated":"2018-09-03T04:12:37.750Z","comments":true,"path":"2018/09/03/10_1037A/","link":"","permalink":"http://yoursite.com/2018/09/03/10_1037A/","excerpt":"","text":"Packets传送You have n coins, each of the same value of 1.Distribute them into packets such that any amount x (1≤x≤n) can be formed using some (possibly one or all) number of these packets.Each packet may only be used entirely or not used at all. No packet may be used more than once in the formation of the single x, however it may be reused for the formation of other x’s.Find the minimum number of packets in such a distribution. InputThe only line contains a single integer n(1≤n≤10^9) — the number of coins you have. OutputOutput a single integer — the minimum possible number of packets, satisfying the condition above.Examplesinput 6 output 3 input 2 output 2 NoteIn the first example, three packets with 1, 2 and 3 coins can be made to get any amount x (1≤x≤6).To get 1 use the packet with 1 coin.To get 2 use the packet with 2 coins.To get 3 use the packet with 3 coins.To get 4 use packets with 1 and 3 coins.To get 5 use packets with 2 and 3 coinsTo get 6 use all packets.In the second example, two packets with 1 and 1 coins can be made to get any amount x (1≤x≤2). 题目大意:读不懂题目系列好像是有n个硬币，分到x个口袋里，最终使这x个口袋能组成 1~n之间的所有数 做法：找规律把这个数拆成2进制，有几位数就需要几个袋子，具体原因：找规律 代码：1234567891011121314#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=31;i++)&#123; if((1&lt;&lt;i)&gt;n)&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Codeforce 71A Way Too Long Words （模拟） No.9","slug":"09_71A","date":"2018-08-30T03:44:45.675Z","updated":"2018-08-30T03:44:22.974Z","comments":true,"path":"2018/08/30/09_71A/","link":"","permalink":"http://yoursite.com/2018/08/30/09_71A/","excerpt":"","text":"Way Too Long Words传送Sometimes some words like “localization” or “internationalization” are so long that writing them many times in one text is quite tiresome. Let’s consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation. This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn’t contain any leading zeroes. Thus, “localization” will be spelt as “l10n”, and “internationalization» will be spelt as “i18n”. You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes. InputThe first line contains an integer n (1 ≤ n ≤ 100). Each of the following n lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters. OutputPrint n lines. The i-th line should contain the result of replacing of the i-th word from the input data. Examplesinput 4word localization internationalizationpneumonoultramicroscopicsilicovolcanoconiosis output wordl10ni18np43s 题目大意：看样例猜题意，小于10的字符串直接输出 大于10的字符串省略输出 做法：模拟，练手速，5分钟速写，一遍过 代码：1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n;string s;int main()&#123; while(cin&gt;&gt;n)&#123; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s; if(s.size()&lt;=10) cout&lt;&lt;s&lt;&lt;endl; else&#123; int t=s.size(); cout&lt;&lt;s[0]&lt;&lt;t-2&lt;&lt;s[t-1]&lt;&lt;endl; &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Codeforce 1A Theatre Square （每日一水练读题练手速）No.8","slug":"08_1A ","date":"2018-08-29T14:25:10.687Z","updated":"2018-08-29T15:37:13.120Z","comments":true,"path":"2018/08/29/08_1A /","link":"","permalink":"http://yoursite.com/2018/08/29/08_1A /","excerpt":"","text":"Theatre Square传送Theatre Square in the capital city of Berland has a rectangular shape with the size n × m meters. On the occasion of the city’s anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size a × a. What is the least number of flagstones needed to pave the Square? It’s allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It’s not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square. InputThe input contains three positive integer numbers in the first line: n, m and a (1 ≤ n, m, a ≤ 109). OutputWrite the needed number of flagstones. Examplesinput 6 6 4 output 4 题目大意：n×m的矩阵能由几个a×a的矩阵覆盖 做法：长和宽都覆盖就可以了ans=覆盖长需要的个数*覆盖宽需要的个数 代码：12345678910111213#include&lt;iostream&gt;using namespace std;long long n,m,p,a,b,ans;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;p)&#123; if(n%p==0) a=n/p; else a=(n/p)+1; if(m%p==0) b=m/p; else b=(m/p)+1; ans=a*b; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","categories":[],"tags":[]},{"title":"Codeforce 540C Ice Cave (bfs搜索) No.7","slug":"07_540C","date":"2018-08-26T13:31:17.388Z","updated":"2018-08-27T05:58:50.306Z","comments":true,"path":"2018/08/26/07_540C/","link":"","permalink":"http://yoursite.com/2018/08/26/07_540C/","excerpt":"","text":"Ice Cave传送You play a computer game. Your character stands on some level of a multilevel ice cave. In order to move on forward, you need to descend one level lower and the only way to do this is to fall through the ice. The level of the cave where you are is a rectangular square grid of n rows and m columns. Each cell consists either from intact or from cracked ice. From each cell you can move to cells that are side-adjacent with yours (due to some limitations of the game engine you cannot make jumps on the same place, i.e. jump from a cell to itself). If you move to the cell with cracked ice, then your character falls down through it and if you move to the cell with intact ice, then the ice on this cell becomes cracked. Let’s number the rows with integers from 1 to n from top to bottom and the columns with integers from 1 to m from left to right. Let’s denote a cell on the intersection of the r-th row and the c-th column as (r, c). You are staying in the cell (r1, c1) and this cell is cracked because you’ve just fallen here from a higher level. You need to fall down through the cell (r2, c2) since the exit to the next level is there. Can you do this? InputThe first line contains two integers, n and m (1 ≤ n, m ≤ 500) — the number of rows and columns in the cave description. Each of the next n lines describes the initial state of the level of the cave, each line consists of m characters “.” (that is, intact ice) and “X” (cracked ice). The next line contains two integers, r1 and c1 (1 ≤ r1 ≤ n, 1 ≤ c1 ≤ m) — your initial coordinates. It is guaranteed that the description of the cave contains character ‘X’ in cell (r1, c1), that is, the ice on the starting cell is initially cracked. The next line contains two integers r2 and c2 (1 ≤ r2 ≤ n, 1 ≤ c2 ≤ m) — the coordinates of the cell through which you need to fall. The final cell may coincide with the starting one. OutputIf you can reach the destination, print ‘YES’, otherwise print ‘NO’. Examplesinput4 6X…XX…XX..X..X.……1 62 2outputYESinput5 4.X..…XX.X.…..XX.5 31 1outputNOinput4 7..X.XX..XX..X.X…X..X……2 21 6outputYES NoteIn the first sample test one possible path is: After the first visit of cell (2, 2) the ice on it cracks and when you step there for the second time, your character falls through the ice as intended. 题目大意：走过的路就会变成坑，要求你掉在终点 做法：bfs 走到坑就判断是否是终点 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int dx[]=&#123;0,0,1,-1&#125;;int dy[]=&#123;1,-1,0,0&#125;;int g[505][505];int n,m,sx,sy,ex,ey;char ch;void debug()&#123; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;endl; for(int j=1;j&lt;=m;j++)&#123; cout&lt;&lt;g[i][j]; &#125; &#125;&#125;bool solve()&#123; queue&lt;int&gt; qx; queue&lt;int&gt; qy; qx.push(sx); qy.push(sy); while(!qx.empty())&#123; int tx=qx.front(); int ty=qy.front(); qx.pop();qy.pop(); for(int i=0;i&lt;=3;i++)&#123; int txx=tx+dx[i]; int tyy=ty+dy[i]; if(txx&gt;=1&amp;&amp;txx&lt;=n&amp;&amp;tyy&gt;=1&amp;&amp;tyy&lt;=m)&#123; if(g[txx][tyy]==1)&#123; if(txx==ex&amp;&amp;tyy==ey) return 1; &#125; else&#123; g[txx][tyy]=1; qx.push(txx); qy.push(tyy); &#125; &#125; &#125; &#125; return 0; &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; scanf(\"%c\",&amp;ch); while(ch=='\\n'||ch==' ') scanf(\"%c\",&amp;ch); if(ch=='X') g[i][j]=1; else g[i][j]=0; &#125; &#125; cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey; if(solve()) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl;&#125;","categories":[],"tags":[]},{"title":"Codeforce 540B School Marks （贪心）No.6","slug":"06_540B","date":"2018-08-26T12:53:49.848Z","updated":"2018-08-26T13:35:57.711Z","comments":true,"path":"2018/08/26/06_540B/","link":"","permalink":"http://yoursite.com/2018/08/26/06_540B/","excerpt":"","text":"School Marks传送Little Vova studies programming in an elite school. Vova and his classmates are supposed to write n progress tests, for each test they will get a mark from 1 to p. Vova is very smart and he can write every test for any mark, but he doesn’t want to stand out from the crowd too much. If the sum of his marks for all tests exceeds value x, then his classmates notice how smart he is and start distracting him asking to let them copy his homework. And if the median of his marks will be lower than y points (the definition of a median is given in the notes), then his mom will decide that he gets too many bad marks and forbid him to play computer games. Vova has already wrote k tests and got marks a1, …, ak. He doesn’t want to get into the first or the second situation described above and now he needs to determine which marks he needs to get for the remaining tests. Help him do that. InputThe first line contains 5 space-separated integers: n, k, p, x and y (1 ≤ n ≤ 999, n is odd, 0 ≤ k &lt; n, 1 ≤ p ≤ 1000, n ≤ x ≤ n·p, 1 ≤ y ≤ p). Here n is the number of tests that Vova is planned to write, k is the number of tests he has already written, p is the maximum possible mark for a test, x is the maximum total number of points so that the classmates don’t yet disturb Vova, y is the minimum median point so that mom still lets him play computer games. The second line contains k space-separated integers: a1, …, ak (1 ≤ ai ≤ p) — the marks that Vova got for the tests he has already written. OutputIf Vova cannot achieve the desired result, print “-1”. Otherwise, print n - k space-separated integers — the marks that Vova should get for the remaining tests. If there are multiple possible solutions, print any of them. Examplesinput5 3 5 18 43 5 4output4 1input5 3 5 16 45 5 5output-1 NoteThe median of sequence a1, …, an where n is odd (in this problem n is always odd) is the element staying on (n + 1) / 2 position in the sorted list of ai. In the first sample the sum of marks equals 3 + 5 + 4 + 4 + 1 = 17, what doesn’t exceed 18, that means that Vova won’t be disturbed by his classmates. And the median point of the sequence {1, 3, 4, 4, 5} equals to 4, that isn’t less than 4, so his mom lets him play computer games. Please note that you do not have to maximize the sum of marks or the median mark. Any of the answers: “4 2”, “2 4”, “5 1”, “1 5”, “4 1”, “1 4” for the first test is correct. In the second sample Vova got three ‘5’ marks, so even if he gets two ‘1’ marks, the sum of marks will be 17, that is more than the required value of 16. So, the answer to this test is “-1”. 题目大意：绫小路清隆是个默默无闻的大神，他每次考试都能控制自己的分数1~p。一学期一共n次考试，已经考了k次。他如果总分超过x那他就会被同学关注，如果他所有考试成绩的中位数小于y，那他就会被他妈谈人生。路哥想一直保持默默无闻，请问他剩下的考试应该考多少分？（给出一种解，无解输出-1） 做法：在保证中位数不低于y的情况下尽可能的考1分所以当中位数小于y时考y分当中位数大于等于y时考1分最后判断合法性不合法输出-1 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,k,p,x,y,sum,cnt;int a[10010],ans[10010]; int read()&#123; int res=0,w=1;char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') ch=getchar(); if(ch=='-') w=-1,ch=getchar(); while(isdigit(ch)) res=res*10+ch-'0',ch=getchar(); return res*w; &#125;int main()&#123; n=read();k=read();p=read();x=read();y=read(); for(int i=1;i&lt;=k;i++)&#123; a[i]=read(); sum+=a[i]; &#125; sort(a+1,a+1+k); for(int i=k+1;i&lt;=n;i++)&#123; if(a[i/2]&gt;=y)&#123; ans[++cnt]=1; a[i]=1; sum+=1; &#125; else&#123; ans[++cnt]=y; a[i]=y; sum+=y; &#125; sort(a+1,a+1+i); &#125; if(sum&gt;x||a[n/2+1]&lt;y)&#123; cout&lt;&lt;\"-1\"&lt;&lt;\" \"; &#125; else&#123; for(int i=1;i&lt;=cnt;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;\" \"; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Codeforce 535B Tavas and SaDDas (打表） No.5","slug":"05_535B","date":"2018-08-26T10:38:53.938Z","updated":"2018-08-26T10:38:35.275Z","comments":true,"path":"2018/08/26/05_535B/","link":"","permalink":"http://yoursite.com/2018/08/26/05_535B/","excerpt":"","text":"Tavas and SaDDas传送Once again Tavas started eating coffee mix without water! Keione told him that it smells awful, but he didn’t stop doing that. That’s why Keione told his smart friend, SaDDas to punish him! SaDDas took Tavas’ headphones and told him: “If you solve the following problem, I’ll return it to you.” The problem is: You are given a lucky number n. Lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not. If we sort all lucky numbers in increasing order, what’s the 1-based index of n? Tavas is not as smart as SaDDas, so he asked you to do him a favor and solve this problem so he can have his headphones back. InputThe first and only line of input contains a lucky number n (1 ≤ n ≤ 109). OutputPrint the index of n among all lucky numbers. Examplesinput 4 output 1 input 7 output 2 input 77 output 6 题目大意：只有4或7的数被称之为幸运数 询问n以内的幸运数有几个 做法：发挥NOIP的优良习惯打表 用一个数组储存所有10^9以内的幸运数然后在n搜索就好 数组序号就是其个数 代码：打表代码： 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,ans,t;bool check(int x)&#123; while(x&gt;10)&#123; t=x%10;x/=10; if(t!=7&amp;&amp;t!=4) return 0; &#125; if(x!=7&amp;&amp;x!=4) return 0; else return 1;&#125;int main()&#123;// freopen(\"a.txt\",\"w\",stdout); for(int i=1;i&lt;=1000000000;i++)&#123; if(check(i)) ans++,cout&lt;&lt;i&lt;&lt;\",\"; &#125; cout&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 提交代码： 123456789101112#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[2000]=&#123;0,4,7,44,47,74,77,444,447,474,477,744,747,774,777,4444,4447,4474,4477,4744,4747,4774,4777,7444,7447,7474,7477,7744,7747,7774,7777,44444,44447,44474,44477,44744,44747,44774,44777,47444,47447,47474,47477,47744,47747,47774,47777,74444,74447,74474,74477,74744,74747,74774,74777,77444,77447,77474,77477,77744,77747,77774,77777,444444,444447,444474,444477,444744,444747,444774,444777,447444,447447,447474,447477,447744,447747,447774,447777,474444,474447,474474,474477,474744,474747,474774,474777,477444,477447,477474,477477,477744,477747,477774,477777,744444,744447,744474,744477,744744,744747,744774,744777,747444,747447,747474,747477,747744,747747,747774,747777,774444,774447,774474,774477,774744,774747,774774,774777,777444,777447,777474,777477,777744,777747,777774,777777,4444444,4444447,4444474,4444477,4444744,4444747,4444774,4444777,4447444,4447447,4447474,4447477,4447744,4447747,4447774,4447777,4474444,4474447,4474474,4474477,4474744,4474747,4474774,4474777,4477444,4477447,4477474,4477477,4477744,4477747,4477774,4477777,4744444,4744447,4744474,4744477,4744744,4744747,4744774,4744777,4747444,4747447,4747474,4747477,4747744,4747747,4747774,4747777,4774444,4774447,4774474,4774477,4774744,4774747,4774774,4774777,4777444,4777447,4777474,4777477,4777744,4777747,4777774,4777777,7444444,7444447,7444474,7444477,7444744,7444747,7444774,7444777,7447444,7447447,7447474,7447477,7447744,7447747,7447774,7447777,7474444,7474447,7474474,7474477,7474744,7474747,7474774,7474777,7477444,7477447,7477474,7477477,7477744,7477747,7477774,7477777,7744444,7744447,7744474,7744477,7744744,7744747,7744774,7744777,7747444,7747447,7747474,7747477,7747744,7747747,7747774,7747777,7774444,7774447,7774474,7774477,7774744,7774747,7774774,7774777,7777444,7777447,7777474,7777477,7777744,7777747,7777774,7777777,44444444,44444447,44444474,44444477,44444744,44444747,44444774,44444777,44447444,44447447,44447474,44447477,44447744,44447747,44447774,44447777,44474444,44474447,44474474,44474477,44474744,44474747,44474774,44474777,44477444,44477447,44477474,44477477,44477744,44477747,44477774,44477777,44744444,44744447,44744474,44744477,44744744,44744747,44744774,44744777,44747444,44747447,44747474,44747477,44747744,44747747,44747774,44747777,44774444,44774447,44774474,44774477,44774744,44774747,44774774,44774777,44777444,44777447,44777474,44777477,44777744,44777747,44777774,44777777,47444444,47444447,47444474,47444477,47444744,47444747,47444774,47444777,47447444,47447447,47447474,47447477,47447744,47447747,47447774,47447777,47474444,47474447,47474474,47474477,47474744,47474747,47474774,47474777,47477444,47477447,47477474,47477477,47477744,47477747,47477774,47477777,47744444,47744447,47744474,47744477,47744744,47744747,47744774,47744777,47747444,47747447,47747474,47747477,47747744,47747747,47747774,47747777,47774444,47774447,47774474,47774477,47774744,47774747,47774774,47774777,47777444,47777447,47777474,47777477,47777744,47777747,47777774,47777777,74444444,74444447,74444474,74444477,74444744,74444747,74444774,74444777,74447444,74447447,74447474,74447477,74447744,74447747,74447774,74447777,74474444,74474447,74474474,74474477,74474744,74474747,74474774,74474777,74477444,74477447,74477474,74477477,74477744,74477747,74477774,74477777,74744444,74744447,74744474,74744477,74744744,74744747,74744774,74744777,74747444,74747447,74747474,74747477,74747744,74747747,74747774,74747777,74774444,74774447,74774474,74774477,74774744,74774747,74774774,74774777,74777444,74777447,74777474,74777477,74777744,74777747,74777774,74777777,77444444,77444447,77444474,77444477,77444744,77444747,77444774,77444777,77447444,77447447,77447474,77447477,77447744,77447747,77447774,77447777,77474444,77474447,77474474,77474477,77474744,77474747,77474774,77474777,77477444,77477447,77477474,77477477,77477744,77477747,77477774,77477777,77744444,77744447,77744474,77744477,77744744,77744747,77744774,77744777,77747444,77747447,77747474,77747477,77747744,77747747,77747774,77747777,77774444,77774447,77774474,77774477,77774744,77774747,77774774,77774777,77777444,77777447,77777474,77777477,77777744,77777747,77777774,77777777,444444444,444444447,444444474,444444477,444444744,444444747,444444774,444444777,444447444,444447447,444447474,444447477,444447744,444447747,444447774,444447777,444474444,444474447,444474474,444474477,444474744,444474747,444474774,444474777,444477444,444477447,444477474,444477477,444477744,444477747,444477774,444477777,444744444,444744447,444744474,444744477,444744744,444744747,444744774,444744777,444747444,444747447,444747474,444747477,444747744,444747747,444747774,444747777,444774444,444774447,444774474,444774477,444774744,444774747,444774774,444774777,444777444,444777447,444777474,444777477,444777744,444777747,444777774,444777777,447444444,447444447,447444474,447444477,447444744,447444747,447444774,447444777,447447444,447447447,447447474,447447477,447447744,447447747,447447774,447447777,447474444,447474447,447474474,447474477,447474744,447474747,447474774,447474777,447477444,447477447,447477474,447477477,447477744,447477747,447477774,447477777,447744444,447744447,447744474,447744477,447744744,447744747,447744774,447744777,447747444,447747447,447747474,447747477,447747744,447747747,447747774,447747777,447774444,447774447,447774474,447774477,447774744,447774747,447774774,447774777,447777444,447777447,447777474,447777477,447777744,447777747,447777774,447777777,474444444,474444447,474444474,474444477,474444744,474444747,474444774,474444777,474447444,474447447,474447474,474447477,474447744,474447747,474447774,474447777,474474444,474474447,474474474,474474477,474474744,474474747,474474774,474474777,474477444,474477447,474477474,474477477,474477744,474477747,474477774,474477777,474744444,474744447,474744474,474744477,474744744,474744747,474744774,474744777,474747444,474747447,474747474,474747477,474747744,474747747,474747774,474747777,474774444,474774447,474774474,474774477,474774744,474774747,474774774,474774777,474777444,474777447,474777474,474777477,474777744,474777747,474777774,474777777,477444444,477444447,477444474,477444477,477444744,477444747,477444774,477444777,477447444,477447447,477447474,477447477,477447744,477447747,477447774,477447777,477474444,477474447,477474474,477474477,477474744,477474747,477474774,477474777,477477444,477477447,477477474,477477477,477477744,477477747,477477774,477477777,477744444,477744447,477744474,477744477,477744744,477744747,477744774,477744777,477747444,477747447,477747474,477747477,477747744,477747747,477747774,477747777,477774444,477774447,477774474,477774477,477774744,477774747,477774774,477774777,477777444,477777447,477777474,477777477,477777744,477777747,477777774,477777777,744444444,744444447,744444474,744444477,744444744,744444747,744444774,744444777,744447444,744447447,744447474,744447477,744447744,744447747,744447774,744447777,744474444,744474447,744474474,744474477,744474744,744474747,744474774,744474777,744477444,744477447,744477474,744477477,744477744,744477747,744477774,744477777,744744444,744744447,744744474,744744477,744744744,744744747,744744774,744744777,744747444,744747447,744747474,744747477,744747744,744747747,744747774,744747777,744774444,744774447,744774474,744774477,744774744,744774747,744774774,744774777,744777444,744777447,744777474,744777477,744777744,744777747,744777774,744777777,747444444,747444447,747444474,747444477,747444744,747444747,747444774,747444777,747447444,747447447,747447474,747447477,747447744,747447747,747447774,747447777,747474444,747474447,747474474,747474477,747474744,747474747,747474774,747474777,747477444,747477447,747477474,747477477,747477744,747477747,747477774,747477777,747744444,747744447,747744474,747744477,747744744,747744747,747744774,747744777,747747444,747747447,747747474,747747477,747747744,747747747,747747774,747747777,747774444,747774447,747774474,747774477,747774744,747774747,747774774,747774777,747777444,747777447,747777474,747777477,747777744,747777747,747777774,747777777,774444444,774444447,774444474,774444477,774444744,774444747,774444774,774444777,774447444,774447447,774447474,774447477,774447744,774447747,774447774,774447777,774474444,774474447,774474474,774474477,774474744,774474747,774474774,774474777,774477444,774477447,774477474,774477477,774477744,774477747,774477774,774477777,774744444,774744447,774744474,774744477,774744744,774744747,774744774,774744777,774747444,774747447,774747474,774747477,774747744,774747747,774747774,774747777,774774444,774774447,774774474,774774477,774774744,774774747,774774774,774774777,774777444,774777447,774777474,774777477,774777744,774777747,774777774,774777777,777444444,777444447,777444474,777444477,777444744,777444747,777444774,777444777,777447444,777447447,777447474,777447477,777447744,777447747,777447774,777447777,777474444,777474447,777474474,777474477,777474744,777474747,777474774,777474777,777477444,777477447,777477474,777477477,777477744,777477747,777477774,777477777,777744444,777744447,777744474,777744477,777744744,777744747,777744774,777744777,777747444,777747447,777747474,777747477,777747744,777747747,777747774,777747777,777774444,777774447,777774474,777774477,777774744,777774747,777774774,777774777,777777444,777777447,777777474,777777477,777777744,777777747,777777774,777777777&#125;; int n,ans;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=1022;i++)&#123; if(n&gt;a[i]) ans=i; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[],"tags":[]},{"title":"Codeforce 534B Covered Path （贪心）No.4","slug":"04_534B","date":"2018-08-26T10:26:43.054Z","updated":"2018-08-26T10:30:23.508Z","comments":true,"path":"2018/08/26/04_534B/","link":"","permalink":"http://yoursite.com/2018/08/26/04_534B/","excerpt":"","text":"Covered Path传送The on-board computer on Polycarp’s car measured that the car speed at the beginning of some section of the path equals v1 meters per second, and in the end it is v2 meters per second. We know that this section of the route took exactly t seconds to pass. Assuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by d meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed d in absolute value), find the maximum possible length of the path section in meters. InputThe first line contains two integers v1 and v2 (1 ≤ v1, v2 ≤ 100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively. The second line contains two integers t (2 ≤ t ≤ 100) — the time when the car moves along the segment in seconds, d (0 ≤ d ≤ 10) — the maximum value of the speed change between adjacent seconds. It is guaranteed that there is a way to complete the segment so that: the speed in the first second equals v1,the speed in the last second equals v2,the absolute value of difference of speeds between any two adjacent seconds doesn’t exceed d. OutputPrint the maximum possible length of the path segment in meters. Examplesinput 5 64 2 output 26 input 10 10 10 0 output 100 NoteIn the first sample the sequence of speeds of Polycarpus’ car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters. In the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters. 题目大意：初速度v1 末速度v2 一共t秒 速度每秒能改变[-d,+d]（注意是瞬间改变速度，牛顿的棺材板要压不住了）问最远距离 做法：先一个劲的加速 加速的时候要注意能不能回到v2 代码：12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int v1,v2,t,d,ans;int read()&#123; int res=0,w=1;char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') ch=getchar(); if(ch=='-') w=-1,ch=getchar(); while(isdigit(ch)) res=res*10+ch-'0',ch=getchar(); return res*w; &#125;int main()&#123; v1=read(); v2=read(); t=read(); d=read(); for(int i=0;i&lt;=t-1;i++)&#123; ans+=min(v1+i*d,v2+(t-i-1)*d); &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[],"tags":[]},{"title":"Codeforce 4A Watermelon （模拟水题）No.3","slug":"03_4A","date":"2018-08-22T16:29:58.918Z","updated":"2018-08-26T10:30:59.132Z","comments":true,"path":"2018/08/23/03_4A/","link":"","permalink":"http://yoursite.com/2018/08/23/03_4A/","excerpt":"","text":"Watermelon传送One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed w kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem. Pete and Billy are great fans of even numbers, that’s why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that’s why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight. InputThe first (and the only) input line contains integer number w (1 ≤ w ≤ 100) — the weight of the watermelon bought by the boys. OutputPrint YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case. Examplesinput 8 output YES NoteFor example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos). 题目大意：给出一个数n 询问其是否能拆成两个偶数之和一开始理解错题意了 做法：偶数=偶数+偶数 （2需要特判） ps：要好好学英语呀！ 1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int read()&#123; int res=0,w=1;char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') ch=getchar(); if(ch=='-') w=-1,ch=getchar(); while(isdigit(ch)) res=res*10+ch-'0',ch=getchar(); return res*w; &#125;int main()&#123; int n; n=read(); if(n!=2&amp;&amp;n%2==0) printf(\"YES\\n\"); else printf(\"NO\\n\"); return 0;&#125;","categories":[],"tags":[]},{"title":"Codeforce 118A String Task （字符串）No.2","slug":"02_118A","date":"2018-08-22T10:49:01.119Z","updated":"2018-08-26T10:30:39.632Z","comments":true,"path":"2018/08/22/02_118A/","link":"","permalink":"http://yoursite.com/2018/08/22/02_118A/","excerpt":"","text":"String Task传送Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: deletes all the vowels,inserts a character “.” before each consonant,replaces all uppercase consonants with corresponding lowercase ones.Vowels are letters “A”, “O”, “Y”, “E”, “U”, “I”, and the rest are consonants. The program’s input is exactly one string, it should return the output as a single string, resulting after the program’s processing the initial string. Help Petya cope with this easy task. InputThe first line represents input string of Petya’s program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive. OutputPrint the resulting string. It is guaranteed that this string is not empty. Examplesinput tour output .t.r input Codeforces output .c.d.f.r.c.s input aBAcAba output .b.c.b 题目大意： 字符串处理 只留辅音字母 每个字母变小写 每个辅音字母前面加”.” 做法： 手写 tolowercase函数(大写字母和小写字母ASCII码差32) “y”是半元音！！！！！！！！！！！！没去掉还能A到note15 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;string s;string tolowercase(string str)&#123; for(int i=0;i&lt;str.size();i++)&#123; if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z')&#123; str[i]+=32; &#125; &#125; return str;&#125;int main()&#123; cin&gt;&gt;s; s=tolowercase(s); for(int i=0;i&lt;s.size();i++)&#123; if(s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u'||s[i]=='y') continue; else if(s[i]&lt;='z'&amp;&amp;s[i]&gt;='a')&#123; cout&lt;&lt;\".\"&lt;&lt;s[i]; &#125; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Codefoce 158A Next Round （模拟水题) No.1","slug":"01_158A","date":"2018-08-22T09:53:09.340Z","updated":"2018-08-26T10:30:45.232Z","comments":true,"path":"2018/08/22/01_158A/","link":"","permalink":"http://yoursite.com/2018/08/22/01_158A/","excerpt":"","text":"Next Round传送“Contestant who earns a score equal to or greater than the k-th place finisher’s score will advance to the next round, as long as the contestant earns a positive score…” — an excerpt from contest rules. A total of n participants took part in the contest (n ≥ k), and you already know their scores. Calculate how many participants will advance to the next round. InputThe first line of the input contains two integers n and k (1 ≤ k ≤ n ≤ 50) separated by a single space. The second line contains n space-separated integers a1, a2, …, an (0 ≤ ai ≤ 100), where ai is the score earned by the participant who got the i-th place. The given sequence is non-increasing (that is, for all i from 1 to n - 1 the following condition is fulfilled: ai ≥ ai + 1). OutputOutput the number of participants who advance to the next round. Examplesinput 8 510 9 8 7 7 7 5 5 output 6 input 4 20 0 0 0 output 0 NoteIn the first example the participant on the 5th place earned 7 points. As the participant on the 6th place also earned 7 points, there are 6 advancers. In the second example nobody got a positive score. 题目大意：有n个人的得分 取前k名晋级 要求得分必须大于零才能晋级 求晋级人数 做法：模拟水题 注意有相同得分 和 全是负分的情况 代码：123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int SIZE=10010;int a[SIZE];int n,k,ans,p; int read()&#123; int res=0,w=1;char ch; while(!isdigit(ch)&amp;&amp;ch!='-') ch=getchar(); if(ch=='-') w=-1,ch=getchar(); while(isdigit(ch)) res=res*10+ch-'0',ch=getchar(); return res*w;&#125;bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; n=read();k=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); &#125; sort(a+1,a+n+1,cmp); p=a[k]; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;0&amp;&amp;a[i]&gt;=p) ans++; else break; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]}]}